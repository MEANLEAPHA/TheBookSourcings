<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Chat</title>
        <script src="https://kit.fontawesome.com/ec7a51a641.js" crossorigin="anonymous"></script>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css">
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>
        <script src="https://kit.fontawesome.com/ec7a51a641.js" crossorigin="anonymous"></script>
        <style>
            body{
                background-color: var(--background-color);
                margin: 0;
                padding: 0;
            }
            :root{
                --background-color:white;
                --primary-color:#275791;
                --secondary-color: gainsboro;
                --font-color:rgb(65, 65, 65);
            }
            .dark-theme{
                --background-color:rgb(32, 32, 32);
                --primary-color:#275791;
                --secondary-color: rgba(220, 220, 220, 0.318);
                --font-color:rgb(255, 255, 255);
            }
            .toast{
                display: none;
            }
            #chat-container{
                width: 90%;
                height:99vh;
                margin:3px auto;
                color: var(--font-color);
                border: 1px solid var(--secondary-color);
              
            }
            #chat-container .chat-container-header{
                width: 100%;
                display: flex;
                align-items: center;
                justify-content: start;
                gap: 5px;
                height: 9.8%;
                border-bottom: 1px solid var(--secondary-color);
            }
            .chat-container-body{
                width: 100%;
                height: 90%;
                display: flex;
            }
            #userList{
                width: 30%;
                height: 100%;
                border-right: 1px solid var(--secondary-color);
            }
            .type-of-chat{
                width: 100%;
                height: auto;
                display: flex;
                justify-content: center;
            }
            .btn-type{
                background:none;
                border: none;
                width: calc(100%/3.1);
                color: var(--font-color);
                padding: 12px 5px 12px 5px;
            }
            .btn-type:hover{
                background-color: var(--secondary-color);
            }
            .search-user{
                width: 95%;
                box-shadow: 0px 0px 3px rgba(175, 175, 175, 0.789);
                margin: auto;
                height: auto;
                display: flex;
                align-items: center;
                padding: 5px;
                border-radius: 10px;
            }
            #searchUserTBS{
                width: 95%;
                padding: 3px 0px 3px 0px;
                border: none;
                background: none;
            }
            .search-user:hover{
                box-shadow: 0px 0px 3px var(--primary-color);
            }
            #searchUserTBS:focus{
                outline: none;
            }
            #roomList{
                height: 86%;
                padding: 10px;
                overflow-y: scroll;
                scrollbar-width: none;
            }
            /* Show scrollbar on hover */
            #roomList:hover {
                scrollbar-width: thin; /* Firefox */
            }
            /* Chrome, Edge, Safari */
            #roomList::-webkit-scrollbar {
                width: 0px; /* Hide by default */
            }
            #roomList:hover::-webkit-scrollbar {
                width: 5px; /* Show on hover */
            }
            #roomList::-webkit-scrollbar-thumb {
                background-color:var(--primary-color);
                border-radius: 4px;
            }
            #chatContent{
                width: 70%;
                height: 100%;
            }

.message {
  max-width: 70%;
  padding: 8px 12px;
  border-radius: 12px;
  margin: 5px 0;
  word-wrap: break-word;
  position: relative;
}

.message.me {
  align-self: flex-end;
  background-color: #d1e7ff;
  text-align: right;
}

.message.other {
  align-self: flex-start;
  background-color: #f1f1f1;
  text-align: left;
}

.message .three-dots {
  font-size: 18px;
  cursor: pointer;
  margin-left: 6px;
}

.checkmark {
  font-size: 12px;
  margin-left: 5px;
  color: gray;
}

.checkmark.seen {
  color: #0084ff;
}

.chat-input {
  display: flex;
  border-top: 1px solid #ddd;
  background: white;
  padding: 8px;
}
.chat-input input {
  flex: 1;
  border: none;
  padding: 8px;
  font-size: 14px;
  outline: none;
}
.chat-input button {
  border: none;
  background: #648dff;
  color: white;
  padding: 8px 12px;
  border-radius: 6px;
  cursor: pointer;
}

    .toast button { margin: 5px; }
  /* Highlight unread messages (bold text) */
.room-item.unread .room-last {
  font-weight: 700;
  color: #000;
}

/* Blue dot for unread chats (Messenger style) */
.room-item {
  position: relative; /* Needed for the ::after positioning */
}

.room-item.unread::after {
  content: "";
  position: absolute;
  right: 12px;
  top: 50%;
  transform: translateY(-50%);
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: #0d6efd;
}


           
        </style>
    </head>
    <body>
        <div id="chat-container">
            <div class="chat-container-header">
                <img src="dog.png"  class="userPf">
                <div class="userDetails">
                    <p>Chat</p>
                </div>
            </div>
            <div class="chat-container-body" >
                <div id="userList">
                        <div id="searchUser">
                            <div class="type-of-chat">
                                <button onclick="" id="type-friend" class="btn-type"><i class="fa-solid fa-user-group"></i></button>
                                <button onclick="" id="type-order" class="btn-type"><i class="fa-solid fa-cart-shopping"></i></button>
                                <button onclick="" id="type-archive" class="btn-type"><i class="fa-solid fa-box-archive"></i></button>
                            </div>
                            <div class="search-user">
                                <input type="text" placeholder="Search" id="searchUserTBS">
                                <i class="fa-solid fa-magnifying-glass" id="searchUserIcon"></i>
                            </div>
                        </div>
                        <div id="roomList">
                        </div>
                </div>
                <div id="chatContent">

                </div>
            </div>
        </div>
            <!-- Edit/Delete Toast -->
        <div id="editDeleteToast" class="toast">
        <button id="editBtn">Edit</button>
        <button id="deleteBtn">Delete</button>
        <button id="closeToast">Cancel</button>
        </div>

            <!-- Edit Message Toast -->
        <div id="editMessageToast" class="toast">
        <input type="text" id="editInput" style="width: 80%" />
        <button id="submitEdit">Save</button>
        <button id="cancelEdit">Cancel</button>
        </div>

            <!-- Delete Confirmation Toast -->
        <div id="deleteMessageToast" class="toast">
        <p>Are you sure you want to delete this message?</p>
        <button id="confirmDelete">Yes</button>
        <button id="cancelDelete">Cancel</button>
        </div>
        
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
   <script>
  // === AUTH CHECK ===
  const token = localStorage.getItem("token");
  if (!token) {
    alert("Login required");
    window.location.href = "/login.html";
  }

  const currentUser = JSON.parse(atob(token.split(".")[1])).memberQid;
  const socket = io("https://thebooksourcings.onrender.com", {
    auth: { token },
    transports: ["websocket"],
  });

  const roomList = document.getElementById("roomList");
  const chatContent = document.getElementById("chatContent");
  let activeRoomId = null;
  let activeType = "friend"; // default type

  // === TYPE BUTTONS (friend/order/archive) ===
  const typeButtons = {
    friend: document.getElementById("type-friend"),
    order: document.getElementById("type-order"),
    archive: document.getElementById("type-archive"),
  };

  Object.entries(typeButtons).forEach(([type, btn]) => {
    btn.addEventListener("click", () => {
      Object.values(typeButtons).forEach((b) => b.classList.remove("active"));
      btn.classList.add("active");
      activeType = type;
      loadChatRooms(type);
      chatContent.innerHTML = ""; // clear old messages
    });
  });

  // === LOAD CHAT ROOMS ===
async function loadChatRooms(type = "friend") {
  try {
    roomList.innerHTML = `<p class='loading'>Loading...</p>`;
    const res = await axios.get(
      `https://thebooksourcings.onrender.com/api/chat/rooms?type=${type}`,
      { headers: { Authorization: `Bearer ${token}` } }
    );
    const rooms = res.data.rooms || [];
    roomList.innerHTML = "";

    if (!rooms.length) {
      roomList.innerHTML = `<p class='no-room'>No ${type} chats yet.</p>`;
      return;
    }

    rooms.forEach((room) => {
      const div = document.createElement("div");
      div.className = "room-item d-flex justify-content-between align-items-center";
      div.setAttribute("data-room-id", room.roomId); // ‚úÖ add data-room-id
      div.dataset.roomId = room.roomId;

      // Highlight based on type
      div.style.borderLeft = type === "friend" ? "4px solid #0d6efd" :
                             type === "order" ? "4px solid #198754" :
                             "4px solid #6c757d";

      div.innerHTML = `
        <div class="d-flex align-items-center room-main">
          <img src="${room.otherProfileImg || "default.png"}" class="room-avatar">
          <div class="room-info">
            <p class="room-name">${room.otherUsername}</p>
            <p class="room-last">${room.lastMessage || "No messages yet"}</p>
          </div>
        </div>
        <div class="dropdown">
          <i class="fa-solid fa-ellipsis-vertical" data-bs-toggle="dropdown" aria-expanded="false"></i>
          <ul class="dropdown-menu">
            ${
              type === "archive"
                ? `<li><a class="dropdown-item unarchive-room" href="#">Unarchive</a></li>`
                : `<li><a class="dropdown-item archive-room" href="#">Move to Archive</a></li>`
            }
            <li><a class="dropdown-item delete-room" href="#">Delete Conversation</a></li>
          </ul>
        </div>
      `;

      // Click to open chat only on the main part
      div.querySelector(".room-main").addEventListener("click", () => openRoom(room.roomId));

      // Archive/unarchive
      if (type === "archive") {
        div.querySelector(".unarchive-room").addEventListener("click", async (e) => {
          e.stopPropagation();
          await archiveAction(room.roomId, false);
        });
      } else {
        div.querySelector(".archive-room").addEventListener("click", async (e) => {
          e.stopPropagation();
          await archiveAction(room.roomId, true);
        });
      }

      // Soft delete
      div.querySelector(".delete-room").addEventListener("click", async (e) => {
        e.stopPropagation();
        if (!confirm("Delete this conversation?")) return;
        await deleteRoom(room.roomId);
        loadChatRooms(activeType); // reload list
      });

      roomList.appendChild(div);
    });
  } catch (err) {
    console.error("Failed to load chat rooms:", err);
    roomList.innerHTML = `<p class='error'>Error loading rooms</p>`;
  }
}

  // === OPEN CHAT ROOM ===
  async function openRoom(roomId) {
    activeRoomId = roomId;
    // ‚úÖ Remove unread highlight when user opens this room

    const currentRoomDiv = document.querySelector(`[data-room-id="${roomId}"]`);
    if (currentRoomDiv) currentRoomDiv.classList.remove("unread");

    chatContent.innerHTML = `
      <div id="chatBox" class="chat-box"></div>
      <div class="chat-input">
        <input type="text" id="messageInput" placeholder="Type a message..." />
        <button id="sendBtn"><i class="fa-solid fa-paper-plane"></i></button>
      </div>
    `;

    const chatBox = document.getElementById("chatBox");
    const messageInput = document.getElementById("messageInput");
    const sendBtn = document.getElementById("sendBtn");

    socket.emit("joinRoom", roomId);

    try {
      const res = await axios.get(
        `https://thebooksourcings.onrender.com/api/chat/${roomId}`,
        { headers: { Authorization: `Bearer ${token}` } }
      );
      const messages = res.data.messages || [];
      chatBox.innerHTML = "";

      messages.forEach((msg) => appendMessage(msg, msg.senderQid === currentUser));
      chatBox.scrollTop = chatBox.scrollHeight;

      socket.emit("markRoomSeen", { roomId });
    } catch (err) {
      console.error("Failed to load messages:", err);
    }

    sendBtn.onclick = () => {
      const text = messageInput.value.trim();
      if (!text) return;

      const tempId = "temp_" + Date.now();
      appendMessage(
        { messageId: tempId, message: text, senderQid: currentUser, status: "pending" },
        true
      );
       // ‚úÖ Update room list last message instantly
      const roomDiv = document.querySelector(`[data-room-id="${roomId}"]`);
      if (roomDiv) {
        const lastMsg = roomDiv.querySelector(".room-last");
        if (lastMsg) lastMsg.textContent = text;
      }

      socket.emit("sendMessage", { roomId, message: text, tempId });
      messageInput.value = "";
    };
  }

  // === APPEND MESSAGE ===
  function appendMessage(msg, isMe = false) {
    const chatBox = document.getElementById("chatBox");
    if (!chatBox) return;

    const msgDiv = document.createElement("div");
    msgDiv.className = isMe ? "message me" : "message other";
    msgDiv.dataset.messageId = msg.messageId;

    const textSpan = document.createElement("span");
    textSpan.className = "message-text";
    textSpan.textContent = msg.message;
    msgDiv.appendChild(textSpan);

    // status icon (only show for self)
    if (isMe) {
      const status = document.createElement("span");
      status.className = "status";
      status.style.marginLeft = "6px";
      if (msg.status === "pending") status.innerHTML = `<i class="fa-solid fa-clock"></i>`;
      else if (msg.status === "sent") status.innerHTML = `<i class="fa-solid fa-check"></i>`;
      else if (msg.status === "delivered") status.innerHTML = `<i class="fa-solid fa-check-double"></i>`;
      else if (msg.status === "seen")
        status.innerHTML = `<i class="fa-solid fa-check-double" style="color:#0d6efd"></i>`;
      msgDiv.appendChild(status);

      const threeDots = document.createElement("span");
      threeDots.textContent = "‚ãÆ";
      threeDots.className = "three-dots";
      msgDiv.appendChild(threeDots);
      threeDots.addEventListener("click", () => showEditDeleteToast(msgDiv, msg.messageId));
    }

    chatBox.appendChild(msgDiv);
    chatBox.scrollTop = chatBox.scrollHeight;
  }

  // === UPDATE MESSAGE STATUS ICON ===
  function updateMessageStatus(messageId, status) {
    const msgDiv = document.querySelector(`[data-message-id="${messageId}"]`);
    if (!msgDiv) return;
    const statusEl = msgDiv.querySelector(".status");
    if (!statusEl) return;

    if (status === "sent") statusEl.innerHTML = `<i class="fa-solid fa-check"></i>`;
    if (status === "delivered") statusEl.innerHTML = `<i class="fa-solid fa-check-double"></i>`;
    if (status === "seen")
      statusEl.innerHTML = `<i class="fa-solid fa-check-double" style="color:#0d6efd"></i>`;
  }

  // === SOCKET EVENTS ===
  // socket.on("receiveMessage", (msg) => {
  //   const isMe = msg.senderQid === currentUser;
  //   appendMessage(msg, isMe);

  //   if (!isMe) {
  //     socket.emit("messageDelivered", { messageId: msg.messageId, roomId: msg.roomId });
  //     if (activeRoomId === msg.roomId && document.visibilityState === "visible") {
  //       socket.emit("markRoomSeen", { roomId: msg.roomId });
  //     }
  //   }
  // });
socket.on("receiveMessage", (msg) => {
  const isMe = msg.senderQid === currentUser;
  appendMessage(msg, isMe);

  if (!isMe) {
    socket.emit("messageDelivered", { messageId: msg.messageId, roomId: msg.roomId });

    // ‚úÖ If not currently viewing this room, mark as unread
    if (activeRoomId !== msg.roomId) {
      const roomDiv = document.querySelector(`[data-room-id="${msg.roomId}"]`);
      if (roomDiv) {
        roomDiv.classList.add("unread");

        // Update last message text
        const lastMsg = roomDiv.querySelector(".room-last");
        if (lastMsg) lastMsg.textContent = msg.message;
      }
    }

    // ‚úÖ If user is viewing same room & tab is active ‚Üí mark seen
    if (activeRoomId === msg.roomId && document.visibilityState === "visible") {
      socket.emit("markRoomSeen", { roomId: msg.roomId });
    }
  }
});



  // socket.on("messageSent", (msg) => {
  //   const { tempId } = msg || {};
  //   if (tempId) {
  //     const tempMsg = document.querySelector(`[data-message-id="${tempId}"]`);
  //     if (tempMsg) {
  //       tempMsg.dataset.messageId = msg.messageId;
  //       const statusEl = tempMsg.querySelector(".status");
  //       if (statusEl) statusEl.innerHTML = `<i class="fa-solid fa-check"></i>`;
  //       return;
  //     }
  //   }
  //   appendMessage(msg, msg.senderQid === currentUser);
  // });
  // Store a mapping from tempId ‚Üí realId
const tempIdMap = {};

socket.on("messageSent", (msg) => {
  const { tempId, messageId } = msg;
  if (tempId) {
    const tempMsg = document.querySelector(`[data-message-id="${tempId}"]`);
    if (tempMsg) {
      tempMsg.dataset.messageId = String(messageId); // replace tempId
      tempIdMap[tempId] = messageId; // store mapping
      const statusEl = tempMsg.querySelector(".status");
      if (statusEl) statusEl.innerHTML = `<i class="fa-solid fa-check"></i>`;
      return;
    }
  }
  appendMessage(msg, msg.senderQid === currentUser);
});
// When editing/deleting, normalize messageId
function getRealMessageId(msgId) {
  return tempIdMap[msgId] || msgId; // use DB id if exists
}

  socket.on("messageDelivered", ({ messageIds }) => {
    if (!Array.isArray(messageIds)) return;
    messageIds.forEach((id) => updateMessageStatus(id, "delivered"));
  });

  // socket.on("messageEdited", (data) => {
  //   const msgDiv = document.querySelector(`[data-message-id="${data.messageId}"]`);
  //   if (msgDiv) msgDiv.querySelector(".message-text").textContent = data.newMessage;
  // });

  // socket.on("messageDeleted", (data) => {
  //   const msgDiv = document.querySelector(`[data-message-id="${data.messageId}"]`);
  //   if (msgDiv) msgDiv.remove();
  // });
// ‚úÖ When a message is edited

// socket.on("messageDeleted", (data) => {
//   console.log("[SOCKET] messageDeleted received:", data);

//   const msgIdStr = String(data.messageId);
//   const msgDiv = document.querySelector(`[data-message-id="${msgIdStr}"]`);
//   if (!msgDiv) console.warn("[SOCKET] messageDeleted: msgDiv not found for", msgIdStr);

//   if (msgDiv) msgDiv.remove();
// });

socket.on("messageEdited", (data) => {
  console.log("[SOCKET] messageEdited received:", data);

  const msgIdStr = String(data.messageId); // <- convert to string
  const msgDiv = document.querySelector(`[data-message-id="${msgIdStr}"]`);
  if (!msgDiv) console.warn("[SOCKET] messageEdited: msgDiv not found for", msgIdStr);

  if (msgDiv) {
    msgDiv.querySelector(".message-text").textContent = data.newMessage;
  }
});

socket.on("messageDeleted", ({ messageId, roomId }) => {
  console.log("[SOCKET] messageDeleted received:", { messageId, roomId });

  // Only remove messages if this room is currently open
  if (activeRoomId !== roomId) return;

  const chatBox = document.getElementById("chatBox");
  if (!chatBox) return;

  const msgDiv = chatBox.querySelector(`[data-message-id="${messageId}"]`);
  if (!msgDiv) return;

  msgDiv.remove();
});



  socket.on("roomMessagesSeen", ({ messageIds }) => {
    if (!Array.isArray(messageIds)) return;
    messageIds.forEach((id) => updateMessageStatus(id, "seen"));
  });

  document.addEventListener("visibilitychange", () => {
    if (document.visibilityState === "visible" && activeRoomId) {
      socket.emit("markRoomSeen", { roomId: activeRoomId });
    }
  });

//   socket.on("roomUpdated", ({ roomId, lastMessage, senderQid }) => {
//   const roomEl = document.querySelector(`.room-item[data-room-id="${roomId}"]`);
//   if (!roomEl) return;

//   const lastTextEl = roomEl.querySelector(".room-last");
//   if (lastTextEl) lastTextEl.textContent = lastMessage;

//   // Add unread blue dot if this update came from another user
//   if (roomId !== activeRoomId && senderQid !== currentUser) {
//     roomEl.classList.add("unread");
//   } else {
//     roomEl.classList.remove("unread");
//   }
// });

socket.on("roomLastMessageUpdated", ({ roomId, lastMessage, type, senderQid, deletedMessageId }) => {
  console.log("[SOCKET] roomLastMessageUpdated received:", { roomId, type, senderQid, deletedMessageId, lastMessage });

  // 1Ô∏è‚É£ Select room item
  const roomItem = document.querySelector(`.room-item[data-room-id="${roomId}"]`);
  if (!roomItem) {
    console.warn("[DEBUG] roomItem not found for roomId:", roomId);
    return;
  } else {
    console.log("[DEBUG] roomItem found for roomId:", roomId);
  }

  // 2Ô∏è‚É£ Select last message div
  const lastMsgDiv = roomItem.querySelector(".room-last");
  if (!lastMsgDiv) {
    console.warn("[DEBUG] lastMsgDiv not found for roomId:", roomId);
    return;
  } else {
    console.log("[DEBUG] lastMsgDiv found, current text:", lastMsgDiv.textContent.trim());
  }

  const isOwnMessage = String(senderQid) === String(currentUser);
  const isActiveRoom = activeRoomId === roomId;

  // 3Ô∏è‚É£ Update last message text directly from backend
  lastMsgDiv.textContent = lastMessage.message || "Message deleted";
  console.log("[DEBUG] room-last updated to:", lastMsgDiv.textContent);

  // 4Ô∏è‚É£ Unread logic (keep same as before)
  if (type === "new") {
    if (!isOwnMessage && !isActiveRoom) {
      roomItem.classList.add("unread");
      console.log("[DEBUG] marked unread (new) for room:", roomId);
    } else {
      roomItem.classList.remove("unread");
      console.log("[DEBUG] cleared unread (new) for room:", roomId);
    }
  } else if (type === "edit") {
    if (!isOwnMessage && !isActiveRoom) {
      roomItem.classList.add("unread");
      console.log("[DEBUG] marked unread (edit) for room:", roomId);
    }
  } else if (type === "delete") {
    if (!isOwnMessage && !isActiveRoom) {
      roomItem.classList.add("unread");
      console.log("[DEBUG] marked unread (delete) for room:", roomId);
    } else {
      roomItem.classList.remove("unread");
      console.log("[DEBUG] cleared unread (delete) for room:", roomId);
    }
  }

  console.log("[DEBUG] roomLastMessageUpdated processing finished for room:", roomId);
});


// socket.on("roomLastMessageUpdated", ({ roomId, lastMessage, type, senderQid, deletedMessageId }) => {
//   console.log("[SOCKET] roomLastMessageUpdated:", { roomId, type, senderQid, deletedMessageId, lastMessage });

//   const roomItem = document.querySelector(`.room-item[data-room-id="${roomId}"]`);
//   if (!roomItem || !lastMessage) {
//     console.warn("[SOCKET] roomLastMessageUpdated: roomItem or lastMessage missing", roomId);
//     return;
//   }

//   const lastMsgDiv = roomItem.querySelector(".room-last");
//   if (!lastMsgDiv) {
//     console.warn("[SOCKET] roomLastMessageUpdated: lastMsgDiv missing for room", roomId);
//     return;
//   }

//   const isOwnMessage = String(senderQid) === String(currentUser); // safe compare
//   const isActiveRoom = activeRoomId === roomId;

//   // current last text in sidebar (used to detect whether this update corresponds to the actual last message)
//   const currentLastMessageText = lastMsgDiv.textContent?.trim() || "";

//   // If server sends prevMessage use it; otherwise fallback to comparing text
//   const prevMessageText = lastMessage.prevMessage ?? "";

//   // Consider update as "last-message update" when:
//   // - it's marked "new"
//   // - OR our sidebar currently shows the prevMessage (meaning the edit/delete was for the last message)
//   const isLastMessageUpdate = (type === "new") || (prevMessageText && currentLastMessageText === prevMessageText);

//   // If this is an old-message edit/delete (not the last one) ‚Äî update text only, don't touch unread.
//   if (!isLastMessageUpdate && type !== "new") {
//     if (type === "edit") {
//       lastMsgDiv.textContent = lastMessage.message;
//       console.log("[SOCKET] roomLastMessageUpdated: updated old message text only", roomId);
//     }
//     return;
//   }

//   // ------------ This is the actual last-message branch ------------
//   // Update the sidebar text for the last message (or "Message deleted")
//   lastMsgDiv.textContent = lastMessage.message || "Message deleted";

//   // Unread logic:
//   // - NEW: if someone else sent it and user not in that room -> show unread
//   // - EDIT: if someone else edited the last msg and user not in room -> keep unread
//   // - DELETE:
//   //    * If someone else deleted the last message and user not in that room -> show unread (Message deleted)
//   //    * If sender deleted it (you deleted) OR you're in the active room -> clear unread
//   if (type === "new") {
//     if (!isOwnMessage && !isActiveRoom) {
//       roomItem.classList.add("unread");
//     } else {
//       roomItem.classList.remove("unread");
//     }
//   } else if (type === "edit") {
//     // Only mark unread if edited by other person and the user is not viewing the room
//     if (!isOwnMessage && !isActiveRoom) {
//       roomItem.classList.add("unread");
//     } // otherwise leave unchanged (or you can explicitly remove if you prefer)
//   } else if (type === "delete") {
//     // If the deleted message was the last message, server included deletedMessageId and lastMessage.messageId
//     // For other participants (not the deleter) and not viewing the room -> show blue dot
//     if (!isOwnMessage && !isActiveRoom) {
//       roomItem.classList.add("unread");
//     } else {
//       // deleter or viewer -> remove unread since they already know state
//       roomItem.classList.remove("unread");
//     }
//   }

//   console.log("[SOCKET] roomLastMessageUpdated processed:", { roomId, type, isOwnMessage, isActiveRoom });
// });

// socket.on("roomLastMessageUpdated", ({ roomId, lastMessage, type, senderQid, deletedMessageId }) => {
//   const roomItem = document.querySelector(`.room-item[data-room-id="${roomId}"]`);
//   if (!roomItem || !lastMessage) return;

//   const lastMsgDiv = roomItem.querySelector(".room-last");
//   if (!lastMsgDiv) return;

//   const isOwnMessage = senderQid === currentUser;
//   const isActiveRoom = activeRoomId === roomId;

//   const currentLastMessageText = lastMsgDiv.textContent;
//   const isLastMessageUpdate = type === "new" || currentLastMessageText === lastMessage.prevMessage;

//   if (!isLastMessageUpdate && type !== "new") {
//     // Old message edited/deleted ‚Äî update text only if needed, do NOT touch unread
//     if (type === "edit") lastMsgDiv.textContent = lastMessage.message;
//     return;
//   }

//   // Update last message text
//   lastMsgDiv.textContent = lastMessage.message || "Message deleted";

//   // üîπ Unread logic
//   if (type === "new" && !isOwnMessage && !isActiveRoom) {
//     roomItem.classList.add("unread");
//   } else if (type === "edit" && !isOwnMessage && !isActiveRoom) {
//     // Keep unread dot if last message edited by others
//     roomItem.classList.add("unread");
//   }else if (type === "delete") {
 
//   if (isOwnMessage || isActiveRoom || (deletedMessageId && deletedMessageId === lastMessage.messageId)) {
//     roomItem.classList.remove("unread");
//   }
// }
// });



// socket.on("roomLastMessageUpdated", ({ roomId, lastMessage, type, senderQid }) => {
//   const roomItem = document.querySelector(`.room-item[data-room-id="${roomId}"]`);
//   if (!roomItem || !lastMessage) return;

//   const lastMsgDiv = roomItem.querySelector(".room-last");
//   if (lastMsgDiv) {
//     lastMsgDiv.textContent = lastMessage.message || "Message deleted";
//   }

//   const isOwnMessage = senderQid === currentUser;
//   const isActiveRoom = activeRoomId === roomId;

//   // Only apply unread logic for the last message
//   if (type === "new" && !isOwnMessage && !isActiveRoom) {
//     // New last message from someone else ‚Üí show blue dot
//     roomItem.classList.add("unread");
//   } 
//   else if (type === "edit") {
//     // If the edited message is the last message
//     if (!isOwnMessage && !isActiveRoom) {
//       // keep dot because user hasn‚Äôt opened the room
//       roomItem.classList.add("unread");
//     } else {
//       // sender editing or user inside room ‚Üí remove dot
//       roomItem.classList.remove("unread");
//     }
//   } 
//   else if (type === "delete") {
//     // remove dot only if inside the room or sender deleted
//     if (isOwnMessage || isActiveRoom) {
//       roomItem.classList.remove("unread");
//     }
//   }
// });




  // === TOAST HANDLERS ===
  function showEditDeleteToast(msgDiv, messageId) {
    const toast = document.getElementById("editDeleteToast");
    toast.style.display = "block";

    const editBtn = toast.querySelector("#editBtn");
    const deleteBtn = toast.querySelector("#deleteBtn");
    const closeBtn = toast.querySelector("#closeToast");

    editBtn.onclick = () => {
      toast.style.display = "none";
      showEditMessageToast(msgDiv, messageId);
    };
    deleteBtn.onclick = () => {
      toast.style.display = "none";
      showDeleteMessageToast(messageId);
    };
    closeBtn.onclick = () => {
      toast.style.display = "none";
    };
  }

  // function showEditMessageToast(msgDiv, messageId) {
  //   const toast = document.getElementById("editMessageToast");
  //   const input = toast.querySelector("#editInput");
  //   const submit = toast.querySelector("#submitEdit");
  //   const cancel = toast.querySelector("#cancelEdit");

  //   input.value = msgDiv.querySelector(".message-text").textContent;
  //   toast.style.display = "block";

  //   submit.onclick = () => {
  //     const newMessage = input.value.trim();
  //     if (!newMessage) return;
  //     socket.emit("editMessage", { roomId: activeRoomId, messageId, newMessage });
  //     toast.style.display = "none";
  //   };
  //   cancel.onclick = () => (toast.style.display = "none");
  // }
  function showEditMessageToast(msgDiv, messageId) {
  const toast = document.getElementById("editMessageToast");
  const input = toast.querySelector("#editInput");
  const submit = toast.querySelector("#submitEdit");
  const cancel = toast.querySelector("#cancelEdit");

  input.value = msgDiv.querySelector(".message-text").textContent;
  toast.style.display = "block";

submit.onclick = () => {
  const newMessage = input.value.trim();
  if (!newMessage) return;
  const realId = getRealMessageId(messageId);
  console.log("[EDIT] Submitting edit:", { messageId: realId, newMessage, activeRoomId });
  socket.emit("editMessage", { roomId: activeRoomId, messageId: realId, newMessage });
  toast.style.display = "none";
};


  cancel.onclick = () => (toast.style.display = "none");
}


function showDeleteMessageToast(messageId) {
  const toast = document.getElementById("deleteMessageToast");
  const confirm = toast.querySelector("#confirmDelete");
  const cancel = toast.querySelector("#cancelDelete");

  toast.style.display = "block";
confirm.onclick = () => {
  const realId = getRealMessageId(messageId);
  console.log("[DELETE] Deleting message:", { messageId: realId, activeRoomId });
  socket.emit("deleteMessage", { roomId: activeRoomId, messageId: realId });
  toast.style.display = "none";
};
  cancel.onclick = () => (toast.style.display = "none");
}
  // function showDeleteMessageToast(messageId) {
  //   const toast = document.getElementById("deleteMessageToast");
  //   const confirm = toast.querySelector("#confirmDelete");
  //   const cancel = toast.querySelector("#cancelDelete");

  //   toast.style.display = "block";
  //   confirm.onclick = () => {
  //     socket.emit("deleteMessage", { roomId: activeRoomId, messageId });
  //     toast.style.display = "none";
  //   };
  //   cancel.onclick = () => (toast.style.display = "none");
  // }


// === INITIAL LOAD ===
loadChatRooms(activeType);

// === ARCHIVE / UNARCHIVE FUNCTION ===
async function archiveAction(roomId, isArchive) {
  const url = isArchive
    ? `https://thebooksourcings.onrender.com/api/chat/archive/${roomId}`
    : `https://thebooksourcings.onrender.com/api/chat/unarchive/${roomId}`;

  try {
    await axios.put(url, {}, { headers: { Authorization: `Bearer ${token}` } });
    loadChatRooms(activeType); // reload current list
  } catch (err) {
    console.error("‚ùå Archive/Unarchive failed:", err);
  }
};


// delete
async function deleteRoom(roomId) {
  if (!confirm("Delete this conversation?")) return;

  const token = localStorage.getItem("token");
  try {
    const res = await fetch(`/api/chat/delete/${roomId}`, {
      method: "PUT",
      headers: { Authorization: `Bearer ${token}` },
    });

    if (!res.ok) throw new Error("Failed to delete room");

    // Instantly remove from UI
    document.querySelector(`[data-room-id="${roomId}"]`)?.remove();
  } catch (err) {
    console.error(err);
    alert("Could not delete chat");
  }
}
 

</script>

    </body>
</html>