<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Chat</title>
        <script src="https://kit.fontawesome.com/ec7a51a641.js" crossorigin="anonymous"></script>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css">
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>
        <script src="https://kit.fontawesome.com/ec7a51a641.js" crossorigin="anonymous"></script>
        <style>
            body{
                background-color: var(--background-color);
                margin: 0;
                padding: 0;
            }
            :root{
                --background-color:white;
                --primary-color:#275791;
                --secondary-color: gainsboro;
                --font-color:rgb(65, 65, 65);
            }
            .dark-theme{
                --background-color:rgb(32, 32, 32);
                --primary-color:#275791;
                --secondary-color: rgba(220, 220, 220, 0.318);
                --font-color:rgb(255, 255, 255);
            }
            .toast{
                display: none;
            }
            #chat-container{
                width: 90%;
                height:99vh;
                margin:3px auto;
                color: var(--font-color);
                border: 1px solid var(--secondary-color);
              
            }
            #chat-container .chat-container-header{
                width: 100%;
                display: flex;
                align-items: center;
                justify-content: start;
                gap: 5px;
                height: 9.8%;
                border-bottom: 1px solid var(--secondary-color);
            }
            .chat-container-body{
                width: 100%;
                height: 90%;
                display: flex;
            }
            #userList{
                width: 30%;
                height: 100%;
                border-right: 1px solid var(--secondary-color);
            }
            .type-of-chat{
                width: 100%;
                height: auto;
                display: flex;
                justify-content: center;
            }
            .btn-type{
                background:none;
                border: none;
                width: calc(100%/3.1);
                color: var(--font-color);
                padding: 12px 5px 12px 5px;
            }
            .btn-type:hover{
                background-color: var(--secondary-color);
            }
            .search-user{
                width: 95%;
                box-shadow: 0px 0px 3px rgba(175, 175, 175, 0.789);
                margin: auto;
                height: auto;
                display: flex;
                align-items: center;
                padding: 5px;
                border-radius: 10px;
            }
            #searchUserTBS{
                width: 95%;
                padding: 3px 0px 3px 0px;
                border: none;
                background: none;
            }
            .search-user:hover{
                box-shadow: 0px 0px 3px var(--primary-color);
            }
            #searchUserTBS:focus{
                outline: none;
            }
            #roomList{
                height: 86%;
                padding: 10px;
                overflow-y: scroll;
                scrollbar-width: none;
            }
            /* Show scrollbar on hover */
            #roomList:hover {
                scrollbar-width: thin; /* Firefox */
            }
            /* Chrome, Edge, Safari */
            #roomList::-webkit-scrollbar {
                width: 0px; /* Hide by default */
            }
            #roomList:hover::-webkit-scrollbar {
                width: 5px; /* Show on hover */
            }
            #roomList::-webkit-scrollbar-thumb {
                background-color:var(--primary-color);
                border-radius: 4px;
            }
            #chatContent{
                width: 70%;
                height: 100%;
            }

.message {
  max-width: 70%;
  padding: 8px 12px;
  border-radius: 12px;
  margin: 5px 0;
  word-wrap: break-word;
  position: relative;
}

.message.me {
  align-self: flex-end;
  background-color: #d1e7ff;
  text-align: right;
}

.message.other {
  align-self: flex-start;
  background-color: #f1f1f1;
  text-align: left;
}

.message .three-dots {
  font-size: 18px;
  cursor: pointer;
  margin-left: 6px;
}

.checkmark {
  font-size: 12px;
  margin-left: 5px;
  color: gray;
}

.checkmark.seen {
  color: #0084ff;
}

.chat-input {
  display: flex;
  border-top: 1px solid #ddd;
  background: white;
  padding: 8px;
}
.chat-input input {
  flex: 1;
  border: none;
  padding: 8px;
  font-size: 14px;
  outline: none;
}
.chat-input button {
  border: none;
  background: #648dff;
  color: white;
  padding: 8px 12px;
  border-radius: 6px;
  cursor: pointer;
}

    .toast button { margin: 5px; }
  /* Highlight unread messages (bold text) */
.room-item.unread .room-last {
  font-weight: 700;
  color: #000;
}

/* Blue dot for unread chats (Messenger style) */
.room-item {
  position: relative; /* Needed for the ::after positioning */
}

.room-item.unread::after {
  content: "";
  position: absolute;
  right: 12px;
  top: 50%;
  transform: translateY(-50%);
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: #0d6efd;
}


           
        </style>
    </head>
    <body>
        <div id="chat-container">
            <div class="chat-container-header">
                <img src="dog.png"  class="userPf">
                <div class="userDetails">
                    <p>Chat</p>
                </div>
            </div>
            <div class="chat-container-body" >
                <div id="userList">
                        <div id="searchUser">
                            <div class="type-of-chat">
                                <button onclick="" id="type-friend" class="btn-type"><i class="fa-solid fa-user-group"></i></button>
                                <button onclick="" id="type-order" class="btn-type"><i class="fa-solid fa-cart-shopping"></i></button>
                                <button onclick="" id="type-archive" class="btn-type"><i class="fa-solid fa-box-archive"></i></button>
                            </div>
                            <div class="search-user">
                                <input type="text" placeholder="Search" id="searchUserTBS">
                                <i class="fa-solid fa-magnifying-glass" id="searchUserIcon"></i>
                            </div>
                        </div>
                        <div id="roomList">
                        </div>
                </div>
                <div id="chatContent">

                </div>
            </div>
        </div>
            <!-- Edit/Delete Toast -->
        <div id="editDeleteToast" class="toast">
        <button id="editBtn">Edit</button>
        <button id="deleteBtn">Delete</button>
        <button id="closeToast">Cancel</button>
        </div>

            <!-- Edit Message Toast -->
        <div id="editMessageToast" class="toast">
        <input type="text" id="editInput" style="width: 80%" />
        <button id="submitEdit">Save</button>
        <button id="cancelEdit">Cancel</button>
        </div>

            <!-- Delete Confirmation Toast -->
        <div id="deleteMessageToast" class="toast">
        <p>Are you sure you want to delete this message?</p>
        <button id="confirmDelete">Yes</button>
        <button id="cancelDelete">Cancel</button>
        </div>
        
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
   <script>
  // === AUTH CHECK ===
  const token = localStorage.getItem("token");
    if (!token) {
    alert("Login required");
    window.location.href = "/login.html";
  } 
  // ---------- Hybrid unread helpers ----------
const UNREAD_LS_KEY = "unreadRooms_v1";

// --- LocalStorage helpers ---
function getLSUnread() {
  try {
    return JSON.parse(localStorage.getItem(UNREAD_LS_KEY) || "[]");
  } catch (e) { return []; }
}

function setLSUnread(list) {
  localStorage.setItem(UNREAD_LS_KEY, JSON.stringify(list));
}

function markRoomUnreadLS(roomId) {
  const arr = getLSUnread();
  if (!arr.includes(String(roomId))) {
    arr.push(String(roomId));
    setLSUnread(arr);
  }
}

function clearRoomUnreadLS(roomId) {
  const arr = getLSUnread().filter(id => String(id) !== String(roomId));
  setLSUnread(arr);
}

// --- Load unread rooms from server and apply UI + LS ---
async function loadUnreadRooms() {
  try {
    const res = await fetch("https://thebooksourcings.onrender.com/api/chat/unreadRooms", {
      headers: { Authorization: `Bearer ${localStorage.getItem("token")}` }
    });
    const data = await res.json();
    if (!data.ok) return;

    const unreadRooms_v1 = data.rooms.map(r => String(r.roomId));
    setLSUnread(unreadRooms_v1);

    console.log("üì• Loaded unread rooms from DB:", unreadRooms_v1);

    unreadRooms_v1.forEach(roomId => {
      const roomItem = document.querySelector(`.room-item[data-room-id="${roomId}"]`);
      if (roomItem) roomItem.classList.add("unread");
    });
  } catch (err) {
    console.error("‚ùå Failed to load unread rooms:", err);
  }
}
// --- Apply LS unread instantly (fast UI feedback) ---
document.addEventListener("DOMContentLoaded", () => {
  const lsUnread = getLSUnread();
  lsUnread.forEach(roomId => {
    const roomItem = document.querySelector(`.room-item[data-room-id="${roomId}"]`);
    if (roomItem) roomItem.classList.add("unread");
  });
});


  const currentUser = JSON.parse(atob(token.split(".")[1])).memberQid;
  const socket = io("https://thebooksourcings.onrender.com", {
    auth: { token },
    transports: ["websocket"],
  });

  const roomList = document.getElementById("roomList");
  const chatContent = document.getElementById("chatContent");
  let activeRoomId = null;
  let activeType = "friend"; // default type

  // === TYPE BUTTONS (friend/order/archive) ===
  const typeButtons = {
    friend: document.getElementById("type-friend"),
    order: document.getElementById("type-order"),
    archive: document.getElementById("type-archive"),
  };

  Object.entries(typeButtons).forEach(([type, btn]) => {
    btn.addEventListener("click", () => {
      Object.values(typeButtons).forEach((b) => b.classList.remove("active"));
      btn.classList.add("active");
      activeType = type;
      loadChatRooms(type);
      chatContent.innerHTML = ""; // clear old messages
    });
  });

  // === LOAD CHAT ROOMS ===
async function loadChatRooms(type = "friend") {
  try {
    roomList.innerHTML = `<p class='loading'>Loading...</p>`;
    const res = await axios.get(
      `https://thebooksourcings.onrender.com/api/chat/rooms?type=${type}`,
      { headers: { Authorization: `Bearer ${token}` } }
    );
    const rooms = res.data.rooms || [];
    roomList.innerHTML = "";

    if (!rooms.length) {
      roomList.innerHTML = `<p class='no-room'>No ${type} chats yet.</p>`;
      return;
    }

    rooms.forEach((room) => {
      const div = document.createElement("div");
      div.className = "room-item d-flex justify-content-between align-items-center";
      div.setAttribute("data-room-id", room.roomId); // ‚úÖ add data-room-id
      div.dataset.roomId = room.roomId;

      // Highlight based on type
      div.style.borderLeft = type === "friend" ? "4px solid #0d6efd" :
                             type === "order" ? "4px solid #198754" :
                             "4px solid #6c757d";

      div.innerHTML = `
        <div class="d-flex align-items-center room-main">
          <img src="${room.otherProfileImg || "default.png"}" class="room-avatar">
          <div class="room-info">
            <p class="room-name">${room.otherUsername}</p>
            <p class="room-last">${room.lastMessage || "No messages yet"}</p>
          </div>
        </div>
        <div class="dropdown">
          <i class="fa-solid fa-ellipsis-vertical" data-bs-toggle="dropdown" aria-expanded="false"></i>
          <ul class="dropdown-menu">
            ${
              type === "archive"
                ? `<li><a class="dropdown-item unarchive-room" href="#">Unarchive</a></li>`
                : `<li><a class="dropdown-item archive-room" href="#">Move to Archive</a></li>`
            }
            <li><a class="dropdown-item delete-room" href="#">Delete Conversation</a></li>
          </ul>
        </div>
      `;

      // Click to open chat only on the main part
      div.querySelector(".room-main").addEventListener("click", () => openRoom(room.roomId));

      // Archive/unarchive
      if (type === "archive") {
        div.querySelector(".unarchive-room").addEventListener("click", async (e) => {
          e.stopPropagation();
          await archiveAction(room.roomId, false);
        });
      } else {
        div.querySelector(".archive-room").addEventListener("click", async (e) => {
          e.stopPropagation();
          await archiveAction(room.roomId, true);
        });
      }

      // Soft delete
      div.querySelector(".delete-room").addEventListener("click", async (e) => {
        e.stopPropagation();
        if (!confirm("Delete this conversation?")) return;
        await deleteRoom(room.roomId);
        loadChatRooms(activeType); // reload list
      });

      roomList.appendChild(div);
    });
     // --- ‚úÖ APPLY UNREAD AFTER ROOMS ARE LOADED ---
 
document.addEventListener("DOMContentLoaded", () => {
  const ls = getLSUnread();
  ls.forEach(rid => {
    const roomEl = document.querySelector(`.room-item[data-room-id="${rid}"]`);
    if (roomEl) roomEl.classList.add("unread");
  });
});

  } catch (err) {
    console.error("Failed to load chat rooms:", err);
    roomList.innerHTML = `<p class='error'>Error loading rooms</p>`;
  }
}


// 2) Fetch database truth and sync localStorage ‚Üí run after you have token
// (async function syncUnreadFromServer() {
//   try {
//     const res = await fetch(`https://thebooksourcings.onrender.com/api/chat/unreadRooms`, {
//       headers: { Authorization: `Bearer ${token}` }
//     });
//     const data = await res.json();
//     const dbRooms = (data && data.rooms) ? data.rooms.map(r => String(r.roomId)) : [];
//     // Overwrite LS with DB truth
//     setLSUnread(dbRooms);

//     // Update UI to match DB
//     document.querySelectorAll(".room-item").forEach(el => {
//       const rid = String(el.dataset.roomId);
//       if (dbRooms.includes(rid)) el.classList.add("unread");
//       else el.classList.remove("unread");
//     });
//   } catch (err) {
//     console.error("Failed to sync unread from server:", err);
//   }
// })();


  // === OPEN CHAT ROOM ===
  async function openRoom(roomId) {
    activeRoomId = roomId;
    // ‚úÖ Remove unread highlight when user opens this room

    const currentRoomDiv = document.querySelector(`[data-room-id="${roomId}"]`);
    if (currentRoomDiv) currentRoomDiv.classList.remove("unread");
    clearRoomUnreadLS(roomId);

    // also tell server to clear unread for this member
    fetch(`https://thebooksourcings.onrender.com/api/chat/unreadRooms/${roomId}`, {
      method: "DELETE",
      headers: { Authorization: `Bearer ${token}` }
    }).catch(err => console.error("Failed to clear unread on server:", err));

    chatContent.innerHTML = `
      <div id="chatBox" class="chat-box"></div>
      <div class="chat-input">
        <input type="text" id="messageInput" placeholder="Type a message..." />
        <button id="sendBtn"><i class="fa-solid fa-paper-plane"></i></button>
      </div>
    `;

    const chatBox = document.getElementById("chatBox");
    const messageInput = document.getElementById("messageInput");
    const sendBtn = document.getElementById("sendBtn");

    socket.emit("joinRoom", roomId);

    try {
      const res = await axios.get(
        `https://thebooksourcings.onrender.com/api/chat/${roomId}`,
        { headers: { Authorization: `Bearer ${token}` } }
      );
      const messages = res.data.messages || [];
      chatBox.innerHTML = "";

      messages.forEach((msg) => appendMessage(msg, msg.senderQid === currentUser));
      chatBox.scrollTop = chatBox.scrollHeight;

      socket.emit("markRoomSeen", { roomId });
    } catch (err) {
      console.error("Failed to load messages:", err);
    }

    sendBtn.onclick = () => {
      const text = messageInput.value.trim();
      if (!text) return;

      const tempId = "temp_" + Date.now();
      appendMessage(
        { messageId: tempId, message: text, senderQid: currentUser, status: "pending" },
        true
      );
       // ‚úÖ Update room list last message instantly
      const roomDiv = document.querySelector(`[data-room-id="${roomId}"]`);
      if (roomDiv) {
        const lastMsg = roomDiv.querySelector(".room-last");
        if (lastMsg) lastMsg.textContent = text;
      }

      socket.emit("sendMessage", { roomId, message: text, tempId });
      messageInput.value = "";
    };
  }

  // === APPEND MESSAGE ===
  function appendMessage(msg, isMe = false) {
    const chatBox = document.getElementById("chatBox");
    if (!chatBox) return;

    const msgDiv = document.createElement("div");
    msgDiv.className = isMe ? "message me" : "message other";
    msgDiv.dataset.messageId = msg.messageId;

    const textSpan = document.createElement("span");
    textSpan.className = "message-text";
    textSpan.textContent = msg.message;
    msgDiv.appendChild(textSpan);

    // status icon (only show for self)
    if (isMe) {
      const status = document.createElement("span");
      status.className = "status";
      status.style.marginLeft = "6px";
      if (msg.status === "pending") status.innerHTML = `<i class="fa-solid fa-clock"></i>`;
      else if (msg.status === "sent") status.innerHTML = `<i class="fa-solid fa-check"></i>`;
      else if (msg.status === "delivered") status.innerHTML = `<i class="fa-solid fa-check-double"></i>`;
      else if (msg.status === "seen")
        status.innerHTML = `<i class="fa-solid fa-check-double" style="color:#0d6efd"></i>`;
      msgDiv.appendChild(status);

      const threeDots = document.createElement("span");
      threeDots.textContent = "‚ãÆ";
      threeDots.className = "three-dots";
      msgDiv.appendChild(threeDots);
      threeDots.addEventListener("click", () => showEditDeleteToast(msgDiv, msg.messageId));
    }

    chatBox.appendChild(msgDiv);
    chatBox.scrollTop = chatBox.scrollHeight;
  }

  // === UPDATE MESSAGE STATUS ICON ===
  function updateMessageStatus(messageId, status) {
    const msgDiv = document.querySelector(`[data-message-id="${messageId}"]`);
    if (!msgDiv) return;
    const statusEl = msgDiv.querySelector(".status");
    if (!statusEl) return;

    if (status === "sent") statusEl.innerHTML = `<i class="fa-solid fa-check"></i>`;
    if (status === "delivered") statusEl.innerHTML = `<i class="fa-solid fa-check-double"></i>`;
    if (status === "seen")
      statusEl.innerHTML = `<i class="fa-solid fa-check-double" style="color:#0d6efd"></i>`;
  }

  // === SOCKET EVENTS ===
  // socket.on("receiveMessage", (msg) => {
  //   const isMe = msg.senderQid === currentUser;
  //   appendMessage(msg, isMe);

  //   if (!isMe) {
  //     socket.emit("messageDelivered", { messageId: msg.messageId, roomId: msg.roomId });
  //     if (activeRoomId === msg.roomId && document.visibilityState === "visible") {
  //       socket.emit("markRoomSeen", { roomId: msg.roomId });
  //     }
  //   }
  // });
socket.on("receiveMessage", (msg) => {
  const isMe = msg.senderQid === currentUser;
  appendMessage(msg, isMe);

  if (!isMe) {
    socket.emit("messageDelivered", { messageId: msg.messageId, roomId: msg.roomId });

    // ‚úÖ If not currently viewing this room, mark as unread
    if (activeRoomId !== msg.roomId) {
      const roomDiv = document.querySelector(`[data-room-id="${msg.roomId}"]`);
      if (roomDiv) {
        roomDiv.classList.add("unread");

        // Update last message text
        const lastMsg = roomDiv.querySelector(".room-last");
        if (lastMsg) lastMsg.textContent = msg.message;
      }
    }

    // ‚úÖ If user is viewing same room & tab is active ‚Üí mark seen
    if (activeRoomId === msg.roomId && document.visibilityState === "visible") {
      socket.emit("markRoomSeen", { roomId: msg.roomId });
    }
  }
});



  // socket.on("messageSent", (msg) => {
  //   const { tempId } = msg || {};
  //   if (tempId) {
  //     const tempMsg = document.querySelector(`[data-message-id="${tempId}"]`);
  //     if (tempMsg) {
  //       tempMsg.dataset.messageId = msg.messageId;
  //       const statusEl = tempMsg.querySelector(".status");
  //       if (statusEl) statusEl.innerHTML = `<i class="fa-solid fa-check"></i>`;
  //       return;
  //     }
  //   }
  //   appendMessage(msg, msg.senderQid === currentUser);
  // });
  // Store a mapping from tempId ‚Üí realId
const tempIdMap = {};

socket.on("messageSent", (msg) => {
  const { tempId, messageId } = msg;
  if (tempId) {
    const tempMsg = document.querySelector(`[data-message-id="${tempId}"]`);
    if (tempMsg) {
      tempMsg.dataset.messageId = String(messageId); // replace tempId
      tempIdMap[tempId] = messageId; // store mapping
      const statusEl = tempMsg.querySelector(".status");
      if (statusEl) statusEl.innerHTML = `<i class="fa-solid fa-check"></i>`;
      return;
    }
  }
  appendMessage(msg, msg.senderQid === currentUser);
});
// When editing/deleting, normalize messageId
function getRealMessageId(msgId) {
  return tempIdMap[msgId] || msgId; // use DB id if exists
}

  socket.on("messageDelivered", ({ messageIds }) => {
    if (!Array.isArray(messageIds)) return;
    messageIds.forEach((id) => updateMessageStatus(id, "delivered"));
  });

  // socket.on("messageEdited", (data) => {
  //   const msgDiv = document.querySelector(`[data-message-id="${data.messageId}"]`);
  //   if (msgDiv) msgDiv.querySelector(".message-text").textContent = data.newMessage;
  // });

  // socket.on("messageDeleted", (data) => {
  //   const msgDiv = document.querySelector(`[data-message-id="${data.messageId}"]`);
  //   if (msgDiv) msgDiv.remove();
  // });
// ‚úÖ When a message is edited

// socket.on("messageDeleted", (data) => {
//   console.log("[SOCKET] messageDeleted received:", data);

//   const msgIdStr = String(data.messageId);
//   const msgDiv = document.querySelector(`[data-message-id="${msgIdStr}"]`);
//   if (!msgDiv) console.warn("[SOCKET] messageDeleted: msgDiv not found for", msgIdStr);

//   if (msgDiv) msgDiv.remove();
// });

socket.on("messageEdited", (data) => {
  console.log("[SOCKET] messageEdited received:", data);

  const msgIdStr = String(data.messageId);
  const msgDiv = document.querySelector(`[data-message-id="${msgIdStr}"]`);
  if (!msgDiv) {
    console.warn("[SOCKET] messageEdited: msgDiv not found for", msgIdStr);
    return;
  }

  msgDiv.querySelector(".message-text").textContent = data.newMessage;
});

socket.on("messageDeleted", (data) => {
  console.log("[SOCKET] messageDeleted received:", data);

  const msgIdStr = String(data.messageId);
  const msgDiv = document.querySelector(`[data-message-id="${msgIdStr}"]`);
  if (!msgDiv) {
    console.warn("[SOCKET] messageDeleted: msgDiv not found for", msgIdStr);
    return;
  }

  msgDiv.querySelector(".message-text").textContent = "This message was deleted.";
});




// socket.on("messageDeleted", ({ messageId, roomId }) => {
//   console.log("[SOCKET] messageDeleted received:", { messageId, roomId });

//   // Only remove messages if this room is currently open
//   if (activeRoomId !== roomId) return;

//   const chatBox = document.getElementById("chatBox");
//   if (!chatBox) return;

//   const msgDiv = chatBox.querySelector(`[data-message-id="${messageId}"]`);
//   if (!msgDiv) return;

//   msgDiv.remove();
// });



  socket.on("roomMessagesSeen", ({ messageIds }) => {
    if (!Array.isArray(messageIds)) return;
    messageIds.forEach((id) => updateMessageStatus(id, "seen"));
  });

  document.addEventListener("visibilitychange", () => {
    if (document.visibilityState === "visible" && activeRoomId) {
      socket.emit("markRoomSeen", { roomId: activeRoomId });
    }
  });


// socket.on("roomLastMessageUpdated", ({ roomId, lastMessage, type, senderQid, deletedMessageId }) => {
//   const roomItem = document.querySelector(`.room-item[data-room-id="${roomId}"]`);
//   if (!roomItem || !lastMessage) return;

//   const lastMsgDiv = roomItem.querySelector(".room-last");
//   if (!lastMsgDiv) return;

//   const prevLastMsgId = lastMsgDiv.dataset.lastMessageId || null;
//   lastMsgDiv.dataset.lastMessageId = lastMessage.messageId ?? "deleted";

//   // üß† Always show message or placeholder
//   lastMsgDiv.textContent = lastMessage.message ?? "This message was deleted.";

//   // ‚úÖ Only mark unread for NEW or EDIT
//   if ((type === "new" || type === "edit") && lastMessage.messageId) {
//     const isOwnMessage = String(senderQid) === String(currentUser);
//     const isActiveRoom = activeRoomId === roomId;

//     if (!isOwnMessage && !isActiveRoom) {
//       roomItem.classList.add("unread");
//     } else {
//       roomItem.classList.remove("unread");
//     }
//   }

//   console.log("[SOCKET] roomLastMessageUpdated processed:", {
//     roomId,
//     type,
//     senderQid,
//     deletedMessageId,
//     lastMessageId: lastMessage.messageId,
//     prevLastMsgId,
//     text: lastMsgDiv.textContent
//   });
// });

socket.on("roomLastMessageUpdated", ({ roomId, lastMessage, type, senderQid }) => {
  const roomItem = document.querySelector(`.room-item[data-room-id="${roomId}"]`);
  if (!roomItem || !lastMessage) return;

  const lastMsgDiv = roomItem.querySelector(".room-last");
  if (!lastMsgDiv) return;

  // Update last message text
  lastMsgDiv.textContent = lastMessage.message || "Message deleted";
  lastMsgDiv.dataset.lastMessageId = lastMessage.messageId ?? "deleted";

  const isOwnMessage = String(senderQid) === String(currentUser);
  const isActiveRoom = activeRoomId === roomId;

  // ‚úÖ Unread logic
  if ((type === "new" || type === "edit") && !isOwnMessage && !isActiveRoom) {
    roomItem.classList.add("unread");
    markRoomUnreadLS(roomId);   // store in LS
  } else if (type === "seen" || isOwnMessage || isActiveRoom) {
    roomItem.classList.remove("unread");
    clearRoomUnreadLS(roomId);  // remove from LS
  }
});


// socket.on("roomLastMessageUpdated", ({ roomId, lastMessage, type, senderQid, deletedMessageId }) => {
//   console.log("[SOCKET] roomLastMessageUpdated received:", { roomId, type, senderQid, deletedMessageId, lastMessage });

//   // 1Ô∏è‚É£ Select room item
//   const roomItem = document.querySelector(`.room-item[data-room-id="${roomId}"]`);
//   if (!roomItem) {
//     console.warn("[DEBUG] roomItem not found for roomId:", roomId);
//     return;
//   } else {
//     console.log("[DEBUG] roomItem found for roomId:", roomId);
//   }

//   // 2Ô∏è‚É£ Select last message div
//   const lastMsgDiv = roomItem.querySelector(".room-last");
//   if (!lastMsgDiv) {
//     console.warn("[DEBUG] lastMsgDiv not found for roomId:", roomId);
//     return;
//   } else {
//     console.log("[DEBUG] lastMsgDiv found, current text:", lastMsgDiv.textContent.trim());
//   }

//   const isOwnMessage = String(senderQid) === String(currentUser);
//   const isActiveRoom = activeRoomId === roomId;

//   // 3Ô∏è‚É£ Update last message text directly from backend
//   lastMsgDiv.textContent = lastMessage.message || "Message deleted";
//   console.log("[DEBUG] room-last updated to:", lastMsgDiv.textContent);

//   // 4Ô∏è‚É£ Unread logic (keep same as before)
//   if (type === "new") {
//     if (!isOwnMessage && !isActiveRoom) {
//       roomItem.classList.add("unread");
//       console.log("[DEBUG] marked unread (new) for room:", roomId);
//     } else {
//       roomItem.classList.remove("unread");
//       console.log("[DEBUG] cleared unread (new) for room:", roomId);
//     }
//   } else if (type === "edit") {
//     if (!isOwnMessage && !isActiveRoom) {
//       roomItem.classList.add("unread");
//       console.log("[DEBUG] marked unread (edit) for room:", roomId);
//     }
//   } else if (type === "delete") {
//     if (!isOwnMessage && !isActiveRoom) {
//       roomItem.classList.add("unread");
//       console.log("[DEBUG] marked unread (delete) for room:", roomId);
//     } else {
//       roomItem.classList.remove("unread");
//       console.log("[DEBUG] cleared unread (delete) for room:", roomId);
//     }
//   }

//   console.log("[DEBUG] roomLastMessageUpdated processing finished for room:", roomId);
// });







  // === TOAST HANDLERS ===
  function showEditDeleteToast(msgDiv, messageId) {
    const toast = document.getElementById("editDeleteToast");
    toast.style.display = "block";

    const editBtn = toast.querySelector("#editBtn");
    const deleteBtn = toast.querySelector("#deleteBtn");
    const closeBtn = toast.querySelector("#closeToast");

    editBtn.onclick = () => {
      toast.style.display = "none";
      showEditMessageToast(msgDiv, messageId);
    };
    deleteBtn.onclick = () => {
      toast.style.display = "none";
      showDeleteMessageToast(messageId);
    };
    closeBtn.onclick = () => {
      toast.style.display = "none";
    };
  }

  // function showEditMessageToast(msgDiv, messageId) {
  //   const toast = document.getElementById("editMessageToast");
  //   const input = toast.querySelector("#editInput");
  //   const submit = toast.querySelector("#submitEdit");
  //   const cancel = toast.querySelector("#cancelEdit");

  //   input.value = msgDiv.querySelector(".message-text").textContent;
  //   toast.style.display = "block";

  //   submit.onclick = () => {
  //     const newMessage = input.value.trim();
  //     if (!newMessage) return;
  //     socket.emit("editMessage", { roomId: activeRoomId, messageId, newMessage });
  //     toast.style.display = "none";
  //   };
  //   cancel.onclick = () => (toast.style.display = "none");
  // }
  function showEditMessageToast(msgDiv, messageId) {
  const toast = document.getElementById("editMessageToast");
  const input = toast.querySelector("#editInput");
  const submit = toast.querySelector("#submitEdit");
  const cancel = toast.querySelector("#cancelEdit");

  input.value = msgDiv.querySelector(".message-text").textContent;
  toast.style.display = "block";

submit.onclick = () => {
  const newMessage = input.value.trim();
  if (!newMessage) return;
  const realId = getRealMessageId(messageId);
  console.log("[EDIT] Submitting edit:", { messageId: realId, newMessage, activeRoomId });
  socket.emit("editMessage", { roomId: activeRoomId, messageId: realId, newMessage });
  toast.style.display = "none";
};


  cancel.onclick = () => (toast.style.display = "none");
}


function showDeleteMessageToast(messageId) {
  const toast = document.getElementById("deleteMessageToast");
  const confirm = toast.querySelector("#confirmDelete");
  const cancel = toast.querySelector("#cancelDelete");

  toast.style.display = "block";
confirm.onclick = () => {
  const realId = getRealMessageId(messageId);
  console.log("[DELETE] Deleting message:", { messageId: realId, activeRoomId });
  socket.emit("deleteMessage", { roomId: activeRoomId, messageId: realId });
  toast.style.display = "none";
};
  cancel.onclick = () => (toast.style.display = "none");
}
  // function showDeleteMessageToast(messageId) {
  //   const toast = document.getElementById("deleteMessageToast");
  //   const confirm = toast.querySelector("#confirmDelete");
  //   const cancel = toast.querySelector("#cancelDelete");

  //   toast.style.display = "block";
  //   confirm.onclick = () => {
  //     socket.emit("deleteMessage", { roomId: activeRoomId, messageId });
  //     toast.style.display = "none";
  //   };
  //   cancel.onclick = () => (toast.style.display = "none");
  // }

// async function syncUnreadFromServer() {
//   try {
//     const res = await fetch(`https://thebooksourcings.onrender.com/api/chat/unreadRooms`, {
//       headers: { Authorization: `Bearer ${token}` }
//     });
//     const data = await res.json();
//     const dbRooms = (data && data.rooms) ? data.rooms.map(r => String(r.roomId)) : [];

//     // ‚úÖ Update localStorage
//     setLSUnread(dbRooms);

//     // ‚úÖ Apply unread class to room items
//     document.querySelectorAll(".room-item").forEach(el => {
//       const rid = String(el.dataset.roomId);
//       if (dbRooms.includes(rid)) el.classList.add("unread");
//       else el.classList.remove("unread");
//     });

//     console.log("‚úÖ Synced unread from DB:", dbRooms);
//   } catch (err) {
//     console.error("‚ùå Failed to sync unread from server:", err);
//   }
// }


// === INITIAL LOAD & SYNC UNREADS ===
(async function init() {
  // 1Ô∏è‚É£ Load rooms first
  await loadChatRooms(activeType);

  // 2Ô∏è‚É£ Then fetch unread rooms from DB and apply LS + UI
  await loadUnreadRooms();
})();

// loadChatRooms(activeType);

// === ARCHIVE / UNARCHIVE FUNCTION ===
async function archiveAction(roomId, isArchive) {
  const url = isArchive
    ? `https://thebooksourcings.onrender.com/api/chat/archive/${roomId}`
    : `https://thebooksourcings.onrender.com/api/chat/unarchive/${roomId}`;

  try {
    await axios.put(url, {}, { headers: { Authorization: `Bearer ${token}` } });
    loadChatRooms(activeType); // reload current list
  } catch (err) {
    console.error("‚ùå Archive/Unarchive failed:", err);
  }
};


// delete
async function deleteRoom(roomId) {
  if (!confirm("Delete this conversation?")) return;

  const token = localStorage.getItem("token");
  try {
    const res = await fetch(`/api/chat/delete/${roomId}`, {
      method: "PUT",
      headers: { Authorization: `Bearer ${token}` },
    });

    if (!res.ok) throw new Error("Failed to delete room");

    // Instantly remove from UI
    document.querySelector(`[data-room-id="${roomId}"]`)?.remove();
  } catch (err) {
    console.error(err);
    alert("Could not delete chat");
  }
}
 

</script>

    </body>
</html>