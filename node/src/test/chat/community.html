<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Community Chat</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; background: #f5f5f5; }
    #message-container div { 
        margin-bottom: 10px; 
        padding: 8px 10px; 
        background: #fff; 
        border-radius: 5px; 
        box-shadow: 0 1px 3px rgba(0,0,0,0.1); 
    }
    .msg-text { margin-right: 10px; }
    .createdAt{
        float: right;
        color: grey;
    }
    .owner-btn { margin-left: 5px; cursor: pointer; color: red; font-weight: bold; }
    #form { margin-top: 20px; display: flex; }
    #message-input { flex: 1; padding: 8px; border-radius: 5px; border: 1px solid #ccc; }
    #form button { margin-left: 10px; padding: 8px 15px; border: none; border-radius: 5px; background: #4CAF50; color: white; cursor: pointer; }
    #form button:hover { background: #45a049; }

    /* Center edit toast in the page */
    #editToastWrapper {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 1080;
    }

    /* Center delete toast in the page */
    #deleteToastWrapper {
        position: fixed;
        top: 60%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 1080;
    }

    #reportToastWrapper {
      position: fixed;
      top: 55%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1080;
      width: 300px;
    }


  </style>
</head>
<body>

<div id="message-container"></div>

<form id="form">
  <input type="text" id="message-input" placeholder="Type your message..." required>
  <button type="submit">Send</button>
</form>

<!-- Bootstrap Toast for editing -->
<div id="editToastWrapper">
  <div id="editToast" class="toast align-items-center text-bg-light border-0" role="alert" aria-live="assertive" aria-atomic="true">
    <div class="toast-body">
      <input type="text" id="editMessageInput" class="form-control mb-2">
      <div class="d-flex justify-content-end">
        <button id="cancelEditBtn" type="button" class="btn btn-sm btn-secondary me-2">Cancel</button>
        <button id="saveEditBtn" type="button" class="btn btn-sm btn-primary">Save</button>
      </div>
    </div>
  </div>
</div>

<!-- Bootstrap Toast for deleting -->
<div id="deleteToastWrapper">
  <div id="deleteToast" class="toast align-items-center text-bg-light border-0" role="alert" aria-live="assertive" aria-atomic="true">
    <div class="toast-body">
      <p>Are you sure you want to delete this message?</p>
      <div class="d-flex justify-content-end">
        <button id="cancelDeleteBtn" type="button" class="btn btn-sm btn-secondary me-2">Cancel</button>
        <button id="confirmDeleteBtn" type="button" class="btn btn-sm btn-danger">Delete</button>
      </div>
    </div>
  </div>
</div>

<!-- Report Toast -->
<div id="reportToastWrapper">
  <div id="reportToast" class="toast align-items-center text-bg-light border-0" role="alert" aria-live="assertive" aria-atomic="true">
    <div class="toast-body">
      <h6>Report Post</h6>
      <textarea id="reportReasonInput" class="form-control mb-2" placeholder="Reason..."></textarea>
      <div class="d-flex justify-content-end">
        <button id="cancelReportBtn" type="button" class="btn btn-sm btn-secondary me-2">Cancel</button>
        <button id="submitReportBtn" type="button" class="btn btn-sm btn-danger">Submit</button>
      </div>
    </div>
  </div>
</div>



<script src="/socket.io/socket.io.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
<script>
const API_URL = "https://thebooksourcings.onrender.com";

 function parseJwt (token) {
  try {
    return JSON.parse(atob(token.split('.')[1]));
  } catch (e) {
    return null;
  }
}

const token = localStorage.getItem("token");
let userMemberQid = null;

if (token) {
  const decoded = parseJwt(token);
  userMemberQid = decoded?.memberQid || null;
}

const socket = io(API_URL, { auth: { token } });

// ====== DECLARATIONS ======
// Edit
let editingMessageId = null;
const editToast = new bootstrap.Toast(document.getElementById("editToast"), { autohide: false });
const editInput = document.getElementById("editMessageInput");

// Delete
let deletingMessageId = null;
const deleteToast = new bootstrap.Toast(document.getElementById("deleteToast"), { autohide: false });

// Report
let reportingTargetId = null;
const reportToast = new bootstrap.Toast(document.getElementById("reportToast"), { autohide: false });
const reportReasonInput = document.getElementById("reportReasonInput");

// ====== SOCKET LISTENERS ======
socket.on("connect", () => console.log("Connected:", socket.id));

socket.on("receive-message", (msg) => {
  if (!msg.createFormNow) msg.createFormNow = "just now";
  displayMessage(msg);
});

socket.on("message-updated", ({ message_id, newText }) => {
  const div = document.querySelector(`div[data-id='${message_id}']`);
  if (div) div.querySelector(".msg-text").textContent = newText;
});

socket.on("message-deleted", ({ message_id }) => {
  const div = document.querySelector(`div[data-id='${message_id}']`);
  if (div) div.remove();
});

// ====== LOAD ALL MESSAGES ======
async function loadMessages() {
  try {
    const res = await fetch(`${API_URL}/api/community/display`);
    if (!res.ok) throw new Error("Failed to fetch messages");
    const msgs = await res.json();
    msgs.forEach(displayMessage);
  } catch (err) {
    console.error("Error loading messages:", err);
  }
}
loadMessages();

// ====== SEND MESSAGE ======
const form = document.getElementById("form");
const messageInput = document.getElementById("message-input");

form.addEventListener("submit", async (e) => {
  e.preventDefault();
  const msg = messageInput.value.trim();
  if (!msg) return;

  try {
    const res = await fetch(`${API_URL}/api/community/send`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${token}`
      },
      body: JSON.stringify({ message: msg })
    });
    if (!res.ok) throw new Error("Failed to send message");
    const savedMsg = await res.json();

    savedMsg.createFormNow = "just now"; // instant display
    displayMessage(savedMsg);
    socket.emit("send-message", savedMsg);
    messageInput.value = "";
  } catch (err) {
    console.error("Error sending message:", err);
  }
});

// ====== DISPLAY MESSAGE ======
function displayMessage(msg) {
  const div = document.createElement("div");
  div.dataset.id = msg.message_id;
  div.innerHTML = `
    <span class="msg-text">${msg.message}</span>
    <span class='createdAt'>${msg.createFormNow}</span>
  `;

  // --- LIKE SECTION ---
  const likeSection = document.createElement("div");
  likeSection.style.marginTop = "5px";

  const likeIcon = document.createElement("i");
  likeIcon.className = "fa fa-heart";
  likeIcon.style.cursor = "pointer";
  likeIcon.style.marginRight = "5px";
  likeIcon.style.color = "black";

  const likeCount = document.createElement("span");
  likeCount.textContent = msg.like_count || 0;

  // Load initial like status
  loadLikeInfoForMessage(msg.message_id, likeIcon, likeCount);

  // Toggle like
  likeIcon.onclick = async () => {
    await toggleLikeActivityForMessage(msg.message_id, likeIcon, likeCount);
  };

  likeSection.appendChild(likeIcon);
  likeSection.appendChild(likeCount);
  div.appendChild(likeSection);

  // --- DROPDOWN MENU ---
  const dropdownWrapper = document.createElement("div");
  dropdownWrapper.className = "dropdown";
  dropdownWrapper.style.display = "inline-block";
  dropdownWrapper.style.float = "right";

  const ellipsisBtn = document.createElement("i");
  ellipsisBtn.className = "fa-solid fa-ellipsis";
  ellipsisBtn.setAttribute("data-bs-toggle", "dropdown");
  ellipsisBtn.style.cursor = "pointer";

  const dropdownMenu = document.createElement("ul");
  dropdownMenu.className = "dropdown-menu";

  if (msg.memberQid === userMemberQid) {
    dropdownMenu.innerHTML = `
      <li><a class="dropdown-item edit-option" href="#">Edit</a></li>
      <li><a class="dropdown-item delete-option" href="#">Delete</a></li>
      <li><a class="dropdown-item report-option" href="#">Report</a></li>
    `;
  } else {
    dropdownMenu.innerHTML = `
      <li><a class="dropdown-item report-option" href="#">Report</a></li>
    `;
  }

  dropdownWrapper.appendChild(ellipsisBtn);
  dropdownWrapper.appendChild(dropdownMenu);
  div.appendChild(dropdownWrapper);

  // Dropdown click handlers
  dropdownMenu.querySelectorAll("a").forEach((item) => {
    item.addEventListener("click", (e) => {
      e.preventDefault();
      if (item.classList.contains("edit-option")) {
        editingMessageId = msg.message_id;
        editInput.value = msg.message;
        editToast.show();
      } else if (item.classList.contains("delete-option")) {
        deletingMessageId = msg.message_id;
        deleteToast.show();
      } else if (item.classList.contains("report-option")) {
        reportingTargetId = msg.message_id;
        reportToast.show();
      }
    });
  });

  document.getElementById("message-container").appendChild(div);
}

// ====== LIKE FUNCTIONS ======
async function loadLikeInfoForMessage(messageId, likeIcon, likeCount) {
  try {
    const res = await fetch(`${API_URL}/api/communityPostLike/status/${messageId}`, {
      headers: { "Authorization": `Bearer ${token}` }
    });
    if (!res.ok) throw new Error("Failed to fetch like status");

    const data = await res.json();
    likeCount.textContent = data.post.like_count;
    likeIcon.style.color = data.userStatus.liked ? "red" : "black";
  } catch (err) {
    console.error(err);
  }
}

async function toggleLikeActivityForMessage(messageId, likeIcon, likeCount) {
  try {
    const res = await fetch(`${API_URL}/api/communityPostLike/like/${messageId}`, {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${token}`,
        "Content-Type": "application/json"
      }
    });
    if (!res.ok) throw new Error("Failed to toggle like");

    const data = await res.json();
    likeIcon.style.color = data.liked ? "red" : "black";
    await loadLikeInfoForMessage(messageId, likeIcon, likeCount);
  } catch (err) {
    console.error(err);
  }
}

// ====== EDIT ======
document.getElementById("saveEditBtn").onclick = async () => {
  const newText = editInput.value.trim();
  if (!newText || !editingMessageId) return;
  try {
    await fetch(`${API_URL}/api/community/edit`, {
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${token}`
      },
      body: JSON.stringify({ message_id: editingMessageId, newText })
    });
    socket.emit("edit-message", { message_id: editingMessageId, newText });
    editToast.hide();
    editingMessageId = null;
  } catch (err) {
    console.error(err);
  }
};

// ====== DELETE ======
document.getElementById("confirmDeleteBtn").onclick = async () => {
  if (!deletingMessageId) return;
  try {
    await fetch(`${API_URL}/api/community/delete`, {
      method: "DELETE",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${token}`
      },
      body: JSON.stringify({ message_id: deletingMessageId })
    });
    socket.emit("delete-message", { message_id: deletingMessageId });
    deleteToast.hide();
    deletingMessageId = null;
  } catch (err) {
    console.error(err);
  }
};

// ====== REPORT ======
document.getElementById("submitReportBtn").onclick = async () => {
  const reasonTxt = reportReasonInput.value.trim();
  if (!reasonTxt || !reportingTargetId) return;

  try {
    const res = await fetch(`${API_URL}/api/community/report`, {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${token}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        reasonTxt,
        reportTypeFrom_id: reportingTargetId
      })
    });

    if (!res.ok) throw new Error("Failed to submit report");

    const data = await res.json();
    alert(data.message);
    reportToast.hide();
    reportingTargetId = null;
    reportReasonInput.value = "";
  } catch (err) {
    console.error("Report error:", err);
  }
};

// ====== CANCEL BUTTONS ======
document.getElementById("cancelEditBtn").onclick = () => {
  editingMessageId = null;
  editToast.hide();
};

document.getElementById("cancelDeleteBtn").onclick = () => {
  deletingMessageId = null;
  deleteToast.hide();
};

document.getElementById("cancelReportBtn").onclick = () => {
  reportingTargetId = null;
  reportReasonInput.value = "";
  reportToast.hide();
};

</script>
</body>
</html>



async function loadLikeInfo(messageId) {
  try {
    const res = await fetch(`https://thebooksourcings.onrender.com/api/communityPostLike/status/${messageId}`, {
      headers: {
        "Authorization": `Bearer ${localStorage.getItem("token")}`
      }
    });
    if (!res.ok) throw new Error("Failed to fetch follow status");

    const data = await res.json();

    likeCount.textContent = data.post.like_count;
    LikeIcon.style.color = data.userStatus.liked ? "gold" : "black";
  } catch (err) {
    console.error(err);
  }
}

async function toggleLikeActivity(messageId) {
  try {
    const res = await fetch(`https://thebooksourcings.onrender.com/api/communityPostLike/like/${messageId}`, {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${localStorage.getItem("token")}`,
        "Content-Type": "application/json"
      }
    });
    if (!res.ok) throw new Error(`Failed to toggle follow`);

    const data = await res.json();

    // Update UI with returned state
    likeIcon.style.color = data.liked ? "gold" : "black";

    // Safer: re-fetch updated count instead of manual increment
    await loadChannelInfo(memberQid);

  } catch (err) {
    console.error(err);
  }
}



/// index.js
// Import Express & Middleware
const { instrument } = require("@socket.io/admin-ui")
const express = require('express');
const cors = require('cors');
const path = require('path');
const http = require('http'); 
const db = require("./config/db"); // your MySQL pool/connection
const app = express();
app.use(cors(
    {
        origin: ["https://admin.socket.io", "https://thebooksourcings.onrender.com"],
        credentials: true
    }
));
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// âœ… Serve static files from the src/public folder
app.use(express.static(path.join(__dirname, 'public')));

// âœ… Handle root path and send index.html from src/public
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'index.html'));
});


// Import Routes
const { TheBookSourcingUser } = require('./routes/userRoute');
const trendingRoutes = require('./routes/book/trending/trendingRoutes'); 
const aboutBookInfoRoute = require('./routes/book/about/allAboutRoute');
const similarBookRoute = require('./routes/book/about/simiarBookRoute');
const bookByAuthorRoute = require('./routes/book/about/bookByAuthorsRoute');
const aboutAuthorInfo = require('./routes/book/about/allAboutAuthorInfoRoute');
const aboutAuthorDetails = require('./routes/book/about/aboutAuthorDetailsRoute');
const similarAuthorDetail = require('./routes/book/about/similarAuthorRoutes');
const notableWork = require('./routes/book/about/notableWorkRoutes');
const {bookRoutes} = require('./routes/book/uploadBookRoute/upload');
const getBookByQidRoute = require('./routes/book/uploadBookRoute/paramQueryRoute');
const getMyBooksRoutes = require('./routes/book/uploadBookRoute/queryRoutes');
const displayUserUploadBookRoute = require('./routes/book/displayUserBook/displayBookRoutes');
const viewRoute = require('./routes/book/bookActivity/viewRoute');
const RDSroute = require('./routes/book/bookActivity/RDSroute');
const LAF = require('./routes/book/userBookStatus/LAFroutes');
const followRoute = require('./routes/book/userFollowStatus/followRoute');
const communityRoutes = require('./routes/chat/community/communityRoutes');
const communityLikeRoute =  require('./routes/chat/community/communityLike/communityPostLikeRoutes')
const verifySocketToken  = require('./middleware/verifySocketToken');


// report
const reportCommunityRoute = require('./routes/chat/community/reportPAC/reportRoutes')

// Initialize Routes
TheBookSourcingUser(app);
bookRoutes(app);
app.use('/api/trending', trendingRoutes); // âœ… mount trending API
app.use('/api/aboutBook', aboutBookInfoRoute);
app.use('/api/similar', similarBookRoute);
app.use('/api/bookByAuthor', bookByAuthorRoute);
app.use('/api/aboutAuthor', aboutAuthorInfo);
app.use('/api/author', aboutAuthorDetails);
app.use('/api/authors/similar', similarAuthorDetail);
app.use('/api/authors/notableWork', notableWork);
app.use('/api/getBookByQid', getBookByQidRoute);
app.use('/api/getMyBooks', getMyBooksRoutes);
app.use('/api/books', displayUserUploadBookRoute);
app.use('/api/books/view', viewRoute);
app.use('/api/books', RDSroute);
app.use('/api/LAFbook', LAF);
app.use('/api', followRoute);
app.use("/api/community", communityRoutes);
app.use('/api/communityPostLike', communityLikeRoute);


// report 
app.use("/api/community", reportCommunityRoute)



// Create HTTP server from Express app
const server = http.createServer(app);

// Attach Socket.IO to the same server
const { Server } = require('socket.io');
const io = new Server(server, {
    cors: {
    origin: ["https://admin.socket.io", "https://thebooksourcings.onrender.com"],
    credentials: true
    }
});

io.use(verifySocketToken); 
io.on("connection", (socket) => {
  console.log("Socket connected:", socket.user?.memberQid || "Guest");

  socket.on("send-message", (data) => {
    if (!socket.user) return; // guest cannot send
    socket.broadcast.emit("receive-message", { ...data, memberQid: socket.user.memberQid });
  });

  socket.on("edit-message", (data) => {
    if (!socket.user) return;
    io.emit("message-updated", data);
  });

  socket.on("delete-message", (data) => {
    if (!socket.user) return;
    io.emit("message-deleted", data);
  });
});



instrument(io, {
  namespaceName: "/admin",
  auth: false
});


// Start Server
const port = 3000;
server.listen(port, () => {
    console.log(`ðŸš€ Server running at http://localhost:${port}`);
});




